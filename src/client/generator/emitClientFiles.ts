/**
 * File emission utilities for generated ViewController clients.
 */

import { promises as fs } from "fs";
import path from "path";
import { IDiscoveredCallableMethod, IEmitGeneratedControllerOptions } from "./types.js";

/**
 * Resolves a relative import path from one file to another.
 *
 * @param fromFilePath - Absolute path of importing file.
 * @param targetFilePath - Absolute path of imported file.
 * @returns Relative ESM import path with `.js` extension.
 */
function toRelativeImport(fromFilePath: string, targetFilePath: string): string {
  const fromDirectory = path.dirname(fromFilePath);
  const relativePath = path.relative(fromDirectory, targetFilePath);
  const withForwardSlashes = relativePath.split(path.sep).join("/");
  const withPrefix = withForwardSlashes.startsWith(".")
    ? withForwardSlashes
    : `./${withForwardSlashes}`;

  return withPrefix.replace(/\.ts$/, ".js");
}

/**
 * Renders one generated method block.
 *
 * @param className - Server controller class name.
 * @param callable - Callable method metadata.
 * @returns Generated method source.
 */
function renderGeneratedMethod(
  callable: IDiscoveredCallableMethod,
  viewDataType: string
): string {
  const cleanedJsDoc =
    callable.jsDoc
      ?.split("\n")
      .filter((line) => !line.includes("@param context"))
      .join("\n") ?? "";
  const methodDoc = cleanedJsDoc ? `\n${cleanedJsDoc}\n` : "";

  return `${methodDoc}  async ${callable.methodName}(\n` +
    `    args: ${callable.argsType}\n` +
    `  ): Promise<\n` +
    `    IClientCallableResult<\n` +
    `      ${callable.returnType},\n` +
    `      ${viewDataType}\n` +
    `    >\n` +
    `  > {\n` +
    `    return this.invokeMethod<${callable.returnType}>("${callable.rpcMethodKey}", args);\n` +
    `  }\n`;
}

/**
 * Returns true when type text is a simple identifier import candidate.
 *
 * @param typeText - Type text to inspect.
 * @returns Whether the type can be imported by name.
 */
function isImportableNamedType(typeText: string): boolean {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(typeText.trim());
}

/**
 * Renders generated client class source for one controller.
 *
 * @param options - Emission options.
 * @returns Generated file source text.
 */
function renderGeneratedFile(options: IEmitGeneratedControllerOptions): string {
  const runtimeImportPath = toRelativeImport(
    options.generatedFilePath,
    path.resolve(process.cwd(), "src/client/runtime.ts")
  );
  const modelImportPath = toRelativeImport(options.generatedFilePath, options.modelFilePath);
  const generatedClassName = `${options.controller.className}Generated`;

  const methodsSource = options.controller.callables
    .map((callable) => renderGeneratedMethod(callable, options.controller.viewDataType))
    .join("\n");

  const importableTypeNames = new Set<string>();
  if (isImportableNamedType(options.controller.viewDataType)) {
    importableTypeNames.add(options.controller.viewDataType);
  }
  for (const callable of options.controller.callables) {
    if (isImportableNamedType(callable.argsType)) {
      importableTypeNames.add(callable.argsType);
    }
    if (isImportableNamedType(callable.returnType)) {
      importableTypeNames.add(callable.returnType);
    }
  }

  const modelImportBlock =
    importableTypeNames.size > 0
      ? `import type {\n${Array.from(importableTypeNames)
          .map((typeName) => `  ${typeName},`)
          .join("\n")}\n} from "${modelImportPath}";\n\n`
      : "";

  return `/**\n` +
    ` * AUTO-GENERATED FILE.\n` +
    ` *\n` +
    ` * This file is regenerated by \`npm run generate:client\`.\n` +
    ` * Do not edit manually; extend the wrapper class instead.\n` +
    ` */\n\n` +
    `import {\n` +
    `  ClientViewControllerBase,\n` +
    `  IClientCallableResult,\n` +
    `  IClientRuntime,\n` +
    `} from "${runtimeImportPath}";\n` +
    `${modelImportBlock}` +
    `export class ${generatedClassName} extends ClientViewControllerBase<\n` +
    `  ${options.controller.viewDataType}\n` +
    `> {\n` +
    `  constructor(runtime: IClientRuntime) {\n` +
    `    super(runtime, "${options.controller.viewKey}");\n` +
    `  }\n\n` +
    `${methodsSource}` +
    `}\n`;
}

/**
 * Renders wrapper class source for one generated controller.
 *
 * @param options - Emission options.
 * @returns Wrapper file source text.
 */
function renderWrapperFile(options: IEmitGeneratedControllerOptions): string {
  const generatedImportPath = toRelativeImport(
    options.wrapperFilePath,
    options.generatedFilePath
  );
  const runtimeImportPath = toRelativeImport(
    options.wrapperFilePath,
    path.resolve(process.cwd(), "src/client/runtime.ts")
  );
  const generatedClassName = `${options.controller.className}Generated`;

  return `/**\n` +
    ` * Client-side wrapper for ${options.controller.className}.\n` +
    ` *\n` +
    ` * This file is preserved across client generation runs.\n` +
    ` */\n\n` +
    `import { ${generatedClassName} } from "${generatedImportPath}";\n` +
    `import { IClientRuntime } from "${runtimeImportPath}";\n\n` +
    `export class ${options.controller.className} extends ${generatedClassName} {\n` +
    `  constructor(runtime: IClientRuntime) {\n` +
    `    super(runtime);\n` +
    `  }\n` +
    `}\n`;
}

/**
 * Emits generated and wrapper client files for one controller.
 *
 * @param options - Emission options.
 */
export async function emitGeneratedControllerFiles(
  options: IEmitGeneratedControllerOptions
): Promise<void> {
  await fs.mkdir(path.dirname(options.generatedFilePath), { recursive: true });

  const generatedContent = renderGeneratedFile(options);
  await fs.writeFile(options.generatedFilePath, generatedContent, "utf8");

  try {
    await fs.access(options.wrapperFilePath);
  } catch {
    const wrapperContent = renderWrapperFile(options);
    await fs.mkdir(path.dirname(options.wrapperFilePath), { recursive: true });
    await fs.writeFile(options.wrapperFilePath, wrapperContent, "utf8");
  }
}
