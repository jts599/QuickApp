/**
 * File emission utilities for generated ViewController clients.
 */

import { promises as fs } from "fs";
import path from "path";
import { IDiscoveredCallableMethod, IEmitGeneratedControllerOptions } from "./types.js";

/**
 * Resolves a relative import path from one file to another.
 *
 * @param fromFilePath - Absolute path of importing file.
 * @param targetFilePath - Absolute path of imported file.
 * @returns Relative ESM import path with `.js` extension.
 */
function toRelativeImport(fromFilePath: string, targetFilePath: string): string {
  const fromDirectory = path.dirname(fromFilePath);
  const relativePath = path.relative(fromDirectory, targetFilePath);
  const withForwardSlashes = relativePath.split(path.sep).join("/");
  const withPrefix = withForwardSlashes.startsWith(".")
    ? withForwardSlashes
    : `./${withForwardSlashes}`;

  return withPrefix.replace(/\.ts$/, ".js");
}

/**
 * Renders one generated method block.
 *
 * @param className - Server controller class name.
 * @param callable - Callable method metadata.
 * @returns Generated method source.
 */
function renderGeneratedMethod(
  className: string,
  callable: IDiscoveredCallableMethod
): string {
  const cleanedJsDoc =
    callable.jsDoc
      ?.split("\n")
      .filter((line) => !line.includes("@param context"))
      .join("\n") ?? "";
  const methodDoc = cleanedJsDoc ? `\n${cleanedJsDoc}\n` : "";

  return `${methodDoc}  async ${callable.methodName}(\n` +
    `    args: ClientControllerMethodArgs<typeof ${className}, "${callable.methodName}">\n` +
    `  ): Promise<\n` +
    `    IClientCallableResult<\n` +
    `      ClientControllerMethodResult<typeof ${className}, "${callable.methodName}">,\n` +
    `      ClientControllerViewData<typeof ${className}>\n` +
    `    >\n` +
    `  > {\n` +
    `    return this.invokeMethod<\n` +
    `      ClientControllerMethodResult<typeof ${className}, "${callable.methodName}">\n` +
    `    >("${callable.rpcMethodKey}", args);\n` +
    `  }\n`;
}

/**
 * Renders generated client class source for one controller.
 *
 * @param options - Emission options.
 * @returns Generated file source text.
 */
function renderGeneratedFile(options: IEmitGeneratedControllerOptions): string {
  const runtimeImportPath = toRelativeImport(
    options.generatedFilePath,
    path.resolve(process.cwd(), "src/client/runtime.ts")
  );
  const serverImportPath = toRelativeImport(options.generatedFilePath, options.sourceFilePath);
  const generatedClassName = `${options.controller.className}Generated`;

  const methodsSource = options.controller.callables
    .map((callable) => renderGeneratedMethod(options.controller.className, callable))
    .join("\n");

  return `/**\n` +
    ` * AUTO-GENERATED FILE.\n` +
    ` *\n` +
    ` * This file is regenerated by \`npm run generate:client\`.\n` +
    ` * Do not edit manually; extend the wrapper class instead.\n` +
    ` */\n\n` +
    `import {\n` +
    `  ClientControllerMethodArgs,\n` +
    `  ClientControllerMethodResult,\n` +
    `  ClientControllerViewData,\n` +
    `  ClientViewControllerBase,\n` +
    `  IClientCallableResult,\n` +
    `  IClientRuntime,\n` +
    `} from "${runtimeImportPath}";\n` +
    `import type { ${options.controller.className} } from "${serverImportPath}";\n\n` +
    `export class ${generatedClassName} extends ClientViewControllerBase<\n` +
    `  ClientControllerViewData<typeof ${options.controller.className}>\n` +
    `> {\n` +
    `  constructor(runtime: IClientRuntime) {\n` +
    `    super(runtime, "${options.controller.viewKey}");\n` +
    `  }\n\n` +
    `${methodsSource}` +
    `}\n`;
}

/**
 * Renders wrapper class source for one generated controller.
 *
 * @param options - Emission options.
 * @returns Wrapper file source text.
 */
function renderWrapperFile(options: IEmitGeneratedControllerOptions): string {
  const generatedImportPath = toRelativeImport(
    options.wrapperFilePath,
    options.generatedFilePath
  );
  const runtimeImportPath = toRelativeImport(
    options.wrapperFilePath,
    path.resolve(process.cwd(), "src/client/runtime.ts")
  );
  const generatedClassName = `${options.controller.className}Generated`;

  return `/**\n` +
    ` * Client-side wrapper for ${options.controller.className}.\n` +
    ` *\n` +
    ` * This file is preserved across client generation runs.\n` +
    ` */\n\n` +
    `import { ${generatedClassName} } from "${generatedImportPath}";\n` +
    `import { IClientRuntime } from "${runtimeImportPath}";\n\n` +
    `export class ${options.controller.className} extends ${generatedClassName} {\n` +
    `  constructor(runtime: IClientRuntime) {\n` +
    `    super(runtime);\n` +
    `  }\n` +
    `}\n`;
}

/**
 * Emits generated and wrapper client files for one controller.
 *
 * @param options - Emission options.
 */
export async function emitGeneratedControllerFiles(
  options: IEmitGeneratedControllerOptions
): Promise<void> {
  await fs.mkdir(path.dirname(options.generatedFilePath), { recursive: true });

  const generatedContent = renderGeneratedFile(options);
  await fs.writeFile(options.generatedFilePath, generatedContent, "utf8");

  try {
    await fs.access(options.wrapperFilePath);
  } catch {
    const wrapperContent = renderWrapperFile(options);
    await fs.mkdir(path.dirname(options.wrapperFilePath), { recursive: true });
    await fs.writeFile(options.wrapperFilePath, wrapperContent, "utf8");
  }
}
